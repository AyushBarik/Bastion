mod common;

pub use common::*;

use rusqlite::{Connection, Result};
use prettytable::{Table, row};
use std::io;

use std::error::Error;

#[derive(Debug)] 
struct Service {
    id: Option<i32>,
    service: String,
    nonce: Vec<u8>,
    encrypted_password: Vec<u8>,
    notes: Option<String>
}
fn main() -> Result<(), Box<dyn Error>> {
    let conn = Connection::open("/Users/ayush/Desktop/Rust-ML/Bastion/database.db").unwrap();
    println!("path {:?}", conn);
//maybe use .env 
//create table once
    conn.execute(
        "CREATE TABLE IF NOT EXISTS passwords (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            service TEXT NOT NULL,
            nonce BLOB NOT NULL,
            encrypted_password BLOB NOT NULL,
            notes TEXT

        )",
        (), // empty list of parameters.

        //asks to set the master password 

    )?;

    //Ask for and check password
    println!("Enter Master Password:");
    let mut mpassword = Default::default();
    io::stdin().read_line(&mut mpassword).expect("WRONG PASSWORD");

    //check aaginst database
    let result: ([u8; 32], bool) = common::hashpass(mpassword).expect("FAILED TO HASH");
    if !result.1 {
        println!("WRONG PASSWORD");
        return Ok(())
    }

//display data
    let mut stmt: rusqlite::Statement<'_> = conn.prepare("SELECT id, service, nonce, encrypted_password, notes FROM passwords")?;
    let person_iter = stmt.query_map([], |row| {
        Ok(Service {
            id: row.get(0)?,
            service: row.get(1)?,
            nonce: row.get(2)?,
            encrypted_password: row.get(3)?,
            notes: row.get(4)?
        })
    })?;

    let mut table: Table = Table::new();
    table.add_row(row!["id","service","nonce","encrypted_password","notes"]);

    for person in person_iter {
        let uwperson: Service = person.unwrap();

        let pid: i32 = uwperson.id.unwrap_or(0);
        let pservice: String = uwperson.service;
        let pnonce: String = common::bin_to_hexstring(uwperson.nonce).unwrap_or("MISSING".to_string());
        let pencrypted_password: String = common::bin_to_hexstring(uwperson.encrypted_password).unwrap_or("MISSING".to_string());
        let pnotes: String = uwperson.notes.unwrap_or("None".to_string());

        table.add_row(row![pid,pservice,pnonce,pencrypted_password,pnotes]);
    }

    table.printstd();

    
    loop{
    println!("Type a command (view/insert/delete/exit):");
    let mut command = String::new();
    io::stdin().read_line(&mut command).expect("Failed");

    match command.trim() {
        "insert" => {
            let mut input = String::new();
            
            println!("Enter Service Name:");
            io::stdin().read_line(&mut input)?;
            let service = input.trim().to_string();
            input.clear(); //   MANDATORY
        
            println!("Enter Your Password:");
            io::stdin().read_line(&mut input)?;
            let password = input.trim().to_string();
            //function for String -> Vec(u8)
            //(encrypted password, nonce)
            let encrypted_tuple = common::encrypt_password(&password, &result.0)?;
            let encrypted_password = encrypted_tuple.0;
            let nonce = encrypted_tuple.1;

            input.clear();
        
            println!("Any Additional Notes?:");
            let note = match io::stdin().read_line(&mut input) {
                Ok(..) => input,
                Err(..) => "".to_string(),
            };

            let mut highest_id: Option<i32> = conn.query_row(
                "SELECT MAX(id) FROM passwords",
                [],
                |row| row.get(0),
            )?;
        
            if highest_id == None {
                highest_id = Some(-1);
            }
            
            let me = Service {
                id: Some(highest_id.unwrap() + 1), //AUTOGENERATED LAST ITEM IN DATABASE. 1-INDEXED
                service: service,
                nonce: nonce, //DUMMY NONCE? CHECK LATER
                encrypted_password: encrypted_password,
                notes: Some(note)
            };

            conn.execute(
                "INSERT INTO passwords (id, service, nonce, encrypted_password, notes) VALUES (?1, ?2, ?3, ?4, ?5)",
                (&me.id, &me.service, &me.nonce, &me.encrypted_password, &me.notes),
            )?;
        
        },



        "view" => {
            println!("Enter the service name to view: ");
            let mut input = String::new();
            io::stdin().read_line(&mut input)?;
            let service_name = input.trim().to_string();

            let mut stmt = conn.prepare("SELECT nonce, encrypted_password FROM passwords WHERE service = ?1")?;
            let mut rows = stmt.query([&service_name])?;

            if let Some(row) = rows.next()? {
                let nonce: Vec<u8> = row.get(0)?;
                let encrypted_password: Vec<u8> = row.get(1)?;

                let view = common::decrypt_password(encrypted_password, nonce, &result.0)?;
                println!("P@SSW0RD: {:#?}", view);

            } else {
                println!("No service found with the name '{}'.", service_name);
                continue;
            }


        }

        "delete" => {
            // call delete.rs logic or function
            println!("Enter the service name to delete: ");
            let mut input = String::new();
            io::stdin().read_line(&mut input)?;
            let service = input.trim().to_string();

            let rows_deleted = conn.execute(
                "DELETE FROM passwords WHERE service = ?1",
                [&service],
            )?;
        
            if rows_deleted > 0 {
                println!("Successfully deleted {} row(s) for service '{}'.", rows_deleted, service);
            } else {
                println!("No service found with the name '{}'.", service);
            }
        },

        "exit" => {
            return Ok(())
        }
        _ => {
            println!("Unknown command. Please type 'insert', 'delete', or 'exit'");
            continue;
        }
     }
    }

}


