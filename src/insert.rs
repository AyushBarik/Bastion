use rusqlite::{Connection, Result};
use std::env;
use std::io;
use std::error::Error;

mod common; //FIX TO USE SUPER::COMMON LATER AND FIX MOD HIERARCHY


//INSERT FOR NEW SERVICES - MASTER PASSWORD INSERTION HANDLED SEPERATELY
struct Service {
    id: Option<i32>,
    service: String,
    nonce: Vec<u8>,
    encrypted_password: Vec<u8>,
    notes: Option<String>
}
//WHEN INSERT ID NEED NOT BE INPUTTED AND THE NEXT ONE IS AUTOMATICALLY ASSIGNED
fn main() -> Result<(), Box<dyn Error>> { //implicity result fills in the second paramter from rusqlit error type
    let curr_dir: std::path::PathBuf = env::current_dir().expect("???DIRECTORY NOT FOUND???");
    let path_database: std::path::PathBuf = curr_dir.join("database.db");
    let conn: Connection = Connection::open(path_database)?;

    let mut input = String::new(); //used to fill up service, password, etc.

    println!("Enter Service Name:");
    io::stdin().read_line(&mut input)?;
    let service = input.trim().to_string();
    input.clear(); //   MANDATORY

    println!("Enter You Password:");
    io::stdin().read_line(&mut input)?;
    let password = input.trim().to_string();
    //function for String -> Vec(u8)
    let encrypted_password = common::encrypt_password(password);
    input.clear();

    println!("Any Additional Notes?:");
    let note = match io::stdin().read_line(&mut input) {
        Ok(..) => input,
        Err(..) => "".to_string(),
    };
    




    //MODIFY THE PATH LATER FOR USER
    let me = Service {
        id: None, //AUTOGENERATED LAST ITEM IN DATABASE. 1-INDEXED
        service: service,
        nonce: vec![32,38,49], //DUMMY NONCE? CHECK LATER
        encrypted_password: encrypted_password.unwrap_or(vec![0,0]),
        notes: Some(note)
    };
    conn.execute(
        "INSERT INTO passwords (id, service, nonce, encrypted_password, notes) VALUES (?1, ?2, ?3, ?4, ?5)",
        (&me.id, &me.service, &me.nonce, &me.encrypted_password, &me.notes),
    )?;

    Ok(())
}